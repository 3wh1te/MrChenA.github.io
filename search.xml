<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hook学习]]></title>
    <url>%2F2017%2F06%2F01%2FHook%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1、Hook原理API Hooking有两种，内核态级别的和用户态级别的。内核态级别的API Hooking也是很多病毒的实现原理，而且在微软不断强化其PatchGuard技术之后，已经越来越困难。做为建设四化的四有青年，我们还是把精力集中在用户态级别的API Hooking上好了。用户态的API Hooking其实就是为了在应用程序和Windows之间插一脚，从而达到用户调用的不再直接是Windows提供的函数，而是调用我们提供的函数。我们可以选择把调用转交给真正的Windows提供的函数，也可以选择自己处理掉，如果我们知道怎么处理的话。API Hooking非常强大可以应用在很多地方，比如监测（非安全领域，因为很容易绕过），虚拟化，软件破解等。要实现API Hooking有很多选择，基本上可以分为： 1、木马DLL2、修改导出表 3、修改导入表4、代码重写 实现的难易程度也基本上是上述的顺序。木马DLL是最好实现的，前年我因为需要解码nellymoser编码的音频，但是只有Flash播放器才有它的解码器。所以我就把winmm.dll这个系统提供多媒体功能的dll做了一个木马，实现了拦截wav输出的目的。木马DLL只需要你写一个同名的dll，导出相同名字和签名的函数即可。不过它的限制也最大，最大的原因是windows核心的DLL是不会从当前目录加载的（比如user32.dll），同时它还要求木马DLL必须预先放置在exe的同级目录下。修改导出和导入表限制也很大。真正的王道是代码重写，不过难度陡增。在这个方面比较出名的有Detours（微软研究院的，不过已经没更新了），和madshi（DELPHI领域的，用户众多）。不过最近新出了一种非常强大的库，叫EasyHook。它具有非常独特的特性，支持.NET。也就是说，你可以用C#来写API钩子。这在以前是无法想象的。它的项目地址是这里。 EasyHook其实不光是一个API Hook的库，它还提供了Remote Injection（远程注入）的功能。也就是说，你不但能够在Hook当前进程的API，还能去Hook其他进程的API。 所谓代码重写，是指修改DLL映射到当前进程的内存中的代码（二进制的机器指令）。每个API都会在运行时解析出一个地址，然后程序会用call指令去调用这个地址所包含的机器指令。代码重写就是把这个地址所在位置的机器指令重写了，从而达到从中插一脚的目的。简化后的流程为： 1、调用API地址所在处的指令 2、被改写的代码被执行（一般就是一个jmp指令，跳转到一个更开阔的地方去做更多的事情） 3、执行Hook 4、执行被覆盖的指令（一般是5个字节） 5、跳转回（API地址所在处+5个字节）的位置继续执行原代码 要完成这样一个流程已经很不容易。它需要你懂得80x86的汇编语言，而且要有很强的debug能力。但是这只是一个简化的流程，真正复杂的地方在于： 1、不可覆盖的代码的监测（比如jne就无法被覆盖） 2、Hook的可靠卸载 3、被覆盖指令长度的确定（一般是5个字节，但是那只是一般） 4、不同CPU指令集的支持（64位？） 5、Hook中调用了被Hook的API怎么办？ 对于上述问题考虑的周到与否是衡量一个API Hook库的标准。很高兴的告诉你，EasyHook把上述问题都考虑进去了。而且依靠CLR Hosting API，EasyHook还实现了.NET的API钩子。原理就是EasyHook自己先把API调用拦截下来，然后用CLR Hosting API启动一个CLR的runtime，然后用runtime去加载一个GAC中的Assembly，然后用反射去调用你的代码，并且给你提供了足够的RuntimeInfo，使得你可以知道当前的环境，以及回调原始的API。不过仍然在Hook系统的API的时候，仍然要非常小心死锁的问题。EasyHook也不是完美的。据我个人测试，它远程Hook .NET产生出来的exe有问题。不过这是它的Remote Injection部分的问题（很可能是CreateRemoteThread与CLR冲突导致的）。而且EasyHook确定指令长度那块内嵌的反汇编器来路不明（作者自述是从一个德文论坛上下载的程序反汇编来的），其实可以考虑用distorm代替。 其内部实现有一段关键的汇编代码叫trampoline（蹦床）。这段代码就是那被覆盖的5个字节要jmp到的一段代码，它负责调用你的Hook和善后。所以说如果你用的是.NET写的钩子，这是一个三级跳的过程： 1、应用程序调用API 2、API被调用（其实是我们的jmp指令被调用，因为头5个字节被覆盖了）3、那个5个字节的jmp，跳转到了trampoline，这蹦床被jmp了，哈哈，所以弹了回去 4、trampoline跳转到了EasyHook的Thread Deadlock Barrier 5、EasyHook再用CLR Hosting API跳转到了我们的.NET代码 转载于这里EasyHook地址 2、EasyHook使用教程 3、Detour使用 下载链接1、VS编译出错c:\evan\workspace\1\1\netwowkippack.h(50) : error C2146: 语法错误 : 缺少“;”(在标识符“nSourPort”的前面)c:\evan\workspace\1\1\netwowkippack.h(50) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 intc:\evan\workspace\1\1\netwowkippack.h(50) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 intc:\evan\workspace\1\1\netwowkippack.h(51) : error C2146: 语法错误 : 缺少“;”(在标识符“nDestPort”的前面)c:\evan\workspace\1\1\netwowkippack.h(51) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int 总结了一下，主要有以下原因： （此情况经常出现在大型工程项目中）如果存在两个类的头文件a.h和b.h,在a.h中有这样的语句：#include “b.h”,在b.h文件中有这样的语句：#include “a.h” 且在一个类中有另一个类的对象时 那么就会出现这样的错误。 没有包含要定义的类的头文件。 3.项目中少加了宏定义，导致头文件重复定义或相应宏无法识别。 4.当有多个头文件时，顺序写反也可能导致相关的错误，其根本是头文件中的预编译语句被隐去了。 e.g 1234567#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;WinCrypt.h&gt;#include &lt;string.h&gt; 如果把第二个和第三个写反，一个宏定义就被#if给注了，就会出现类似错误 转载自链接 2、Detours(1) Target函数：要拦截的函数，通常为Windows的API。 (2) Trampoline函数：Target函数的复制品。因为Detours将会改写Target函数，所以先把Target函数复制保存好，一方面仍然保存Target函数的过程调用语义，另一方面便于以后的恢复。 (3) Detour 函数：用来替代Target函数的函数。 (4) Detours在Target函数的开头加入JMP Addressof Detour_ Function指令（共5个字节）把对Target函数的调用引导到自己的Detour函数， 把Target函数的开头的5个字节加上JMP Addressof Target _ Function+5作为Trampoline函数。 123456789101112131415161718192021222324252627282930DetourAttach((PVOID *)&amp;pPresent, New_Present); DWORD nErr = DetourTransactionCommit(); pPresent传入前的值为5d0a10c3，传入后的值为5ce50060（DetourTransactionCommit后） 0:000&gt; u 5d0a10c3 //Hook前函数汇编 d3d9!CBaseDevice::Present: 5d0a10c3 8bff mov edi,edi 5d0a10c5 55 push ebp 5d0a10c6 8bec mov ebp,esp 5d0a10c8 56 push esi 5d0a10c9 57 push edi 5d0a10ca 8b7d08 mov edi,dword ptr [ebp+8] 5d0a10cd 85ff test edi,edi 5d0a10cf 7444 je d3d9!CBaseDevice::Present+0x13 (5d0a1115) d3d9!CBaseDevice::Present://Hook后函数汇编 5d0a10c3 e9dc002fa3 jmp FpsTool1!ILT+415(?New_PresentYGJPAUIDirect3DDevice9PBUtagRECT (003911a4) //5个字节 5d0a10c8 56 push esi 5d0a10c9 57 push edi 5d0a10ca 8b7d08 mov edi,dword ptr [ebp+8] 5d0a10cd 85ff test edi,edi 5d0a10cf 7444 je d3d9!CBaseDevice::Present+0x13 (5d0a1115) 5d0a10d1 8d7704 lea esi,[edi+4] 5d0a10d4 837e1800 cmp dword ptr [esi+18h],0 0:000&gt; u 5ce50060//Hook后pPresent的值，我们可以看到是保存了Hook前函数汇编的前五个字节，再跳转回前面函数 5ce50060 8bff mov edi,edi 5ce50062 55 push ebp 5ce50063 8bec mov ebp,esp 5ce50065 e95e102500 jmp d3d9!CBaseDevice::Present+0x5 (5d0a10c8) 在Detours库中，驱动detours执行的是函数 DetourAttach(…) 1234567LONG DetourAttach( PVOID * ppPointer, PVOID pDetour ); 这个函数的职责是挂接目标API，函数的第一个参数是一个指向将要被挂接函数地址的函数指针，第二个参数是指向实际运行的函数的指针，一般来说是我们定义的替代函数的地址。注意：我们自定义的替代函式一定要与被hook的函数具有相同的参数和返回值。例如，send函数的定义是这样的： 1234567891011int send( __in SOCKET s, __in const char *buf, __in int len, __in int flags); 因此，指向这个函数的指针看起来应该是这样的： int (WINAPI pSend)(SOCKET, const char, int, int) = send; 把函数指针初始化成真正的函数地址是ok的；另外还有一种方式是把函数指针初始化为NULL，然后用函数DetourFindFunction(…) 指向真正的函式地址.把send(…) 和 recv(…)初始化: 12345678int (WINAPI *pSend)(SOCKET s, const char* buf, int len, int flags) = send;int WINAPI MySend(SOCKET s, const char* buf, int len, int flags);int (WINAPI *pRecv)(SOCKET s, char* buf, int len, int flags) = recv;int WINAPI MyRecv(SOCKET s, char* buf, int len, int flags); 现在，需要hook的函数和重定向到的函数已经定义好了。这里使用 WINAPI 是因为这些函数是用 __stdcall 返回值的导出函数，现在开始hook: 123456789101112131415161718192021222324252627282930313233INT APIENTRY DllMain(HMODULE hDLL, DWORD Reason, LPVOID Reserved)&#123; switch(Reason) &#123; case DLL_PROCESS_ATTACH: DisableThreadLibraryCalls(hDLL); DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourAttach(&amp;(PVOID&amp;)pSend, MySend); if(DetourTransactionCommit() == NO_ERROR) OutputDebugString(&quot;send() detoured successfully&quot;); DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourAttach(&amp;(PVOID&amp;)pRecv, MyRecv); if(DetourTransactionCommit() == NO_ERROR) OutputDebugString(&quot;recv() detoured successfully&quot;); break; 它基本上是用上面介绍的步骤开始和结束 —— 初始化，更新detours线程，用DetourAttach(…)开始hook函数，最后调用DetourTransactionCommit() 函数, 当调用成功时返回 NO_ERROR, 失败是返回一些错误码.下面是我们的函数的实现，我发送和接收的信息写入到一个日志文件中: 1234567891011121314151617181920212223242526272829int WINAPI MySend(SOCKET s, const char* buf, int len, int flags)&#123; fopen_s(&amp;pSendLogFile, &quot;C:\\SendLog.txt&quot;, &quot;a+&quot;); fprintf(pSendLogFile, &quot;%s\n&quot;, buf); fclose(pSendLogFile); return pSend(s, buf, len, flags);&#125; int WINAPI MyRecv(SOCKET s, char* buf, int len, int flags)&#123; fopen_s(&amp;pRecvLogFile, &quot;C:\\RecvLog.txt&quot;, &quot;a+&quot;); fprintf(pRecvLogFile, &quot;%s\n&quot;, buf); fclose(pRecvLogFile); return pRecv(s, buf, len, flags);&#125; 还可以hook自定义的c函数、hook类成员函数 链接 3、无法解析的外部命令12345671&gt;Test.obj : error LNK2019: 无法解析的外部符号 _DetourTransactionBegin@0，该符号在函数 &quot;void __cdecl Hook(void)&quot; (?Hook@@YAXXZ) 中被引用1&gt;Test.obj : error LNK2019: 无法解析的外部符号 _DetourTransactionCommit@0，该符号在函数 &quot;void __cdecl Hook(void)&quot; (?Hook@@YAXXZ) 中被引用1&gt;Test.obj : error LNK2019: 无法解析的外部符号 _DetourUpdateThread@4，该符号在函数 &quot;void __cdecl Hook(void)&quot; (?Hook@@YAXXZ) 中被引用1&gt;Test.obj : error LNK2019: 无法解析的外部符号 _DetourAttach@8，该符号在函数 &quot;void __cdecl Hook(void)&quot; (?Hook@@YAXXZ) 中被引用1&gt;Test.obj : error LNK2019: 无法解析的外部符号 _DetourDetach@8，该符号在函数 &quot;void __cdecl UnHook(void)&quot; (?UnHook@@YAXXZ) 中被引用1&gt;Test.obj : error LNK2019: 无法解析的外部符号 _DetourRestoreAfterWith@0，该符号在函数 &quot;void __cdecl Hook(void)&quot; (?Hook@@YAXXZ) 中被引用1&gt;D:\勒索软件的预防\project\Test\Debug\Test.exe : fatal error LNK1120: 6 个无法解析的外部命令 使用VS2012的时候编译出错，出现这个原因两种：1.没有引相应的库 #include “detours.lib”2.引错库了（我就属于后者），因为新建的是win32的程序所以需要引x86的库，如果没有x86的库，可以修改平台配置，改成x64。 4、一些重要函数1.DetourAttach和DetourDetach之前提过，这里就不详细说了。 2.DetourRestoreAfterWithDefinition 1BOOL DetourRestoreAfterWith(VOID); Return value Returns true if the necessary payload was found and the restore succeeded. Error codes The function sets one of the following error codes if it was unable to find the necessary payload or restore the import table. The error code may be retrived after the function has returned by calling GetLastError. ERROR_MOD_NOT_FOUNDCould not find the necessary payload. Remarks The DetourCreateProcessWithDllEx API modifies the in-memory import table of the target PE binary program in the new process it creates. For correct application compatibilty, the changes to the import table should be removed before the application runs. To remove these changes, DetourCreateProcessWithDllEx copies relevant reversal data into a payload in the target process using the DetourCopyPayloadToProcess API. When called in the target process, DetourRestoreAfterWith searches for the necessary payloaded and restores the contents of the import table. For correct results, DetourRestoreAfterWith should be called in the PROCESS_ATTACH portion of the DllMain function of the DLL loaded into the target process. 3.DetourTransactionBegin和DetourTransactionCommit4.DetourUpdateThreadEnlist a thread for update in the current transaction. DefinitionLONG DetourUpdateThread( In HANDLE hThread );ParametershThreadThe handle of the thread to be updated with the pending transaction.Return valueReturns NO_ERROR if successful; otherwise, returns an error code. Error codesERROR_NOT_ENOUGH_MEMORYNot enough memory to record identity of thread.RemarksDetourUpdateThread enlists the specified thread for update when the current transaction, opened by the DetourTransactionBegin API, commits. When a detour transaction commmits, Detours insures that all threads enlisted in the transcation via the DetourUpdateThread API are updated if their instruction pointer lies within the rewritten code in either the target function or the trampoline function. Threads not enlisted in the transaction are not updated when the transaction commits. As a result, they may attempt to execute an illegal combination of old and new code. 5.DetourCreateProcessWithDll在Detour DLL被加载之后，它应该通过调用DetourRestoreAfterWith来反转对内存中引用表的更改。 为了方便逆转这些更改，DetourCreateProcessWithDll使用DetourCopyPayloadToProcess API将相关的反转数据复制到目标进程的有效负载中。 加载的DLL应该调用DetourRestoreAfterWith API来恢复导入表的内容。]]></content>
      <tags>
        <tag>articles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF]]></title>
    <url>%2F2017%2F05%2F26%2FCTF%2F</url>
    <content type="text"><![CDATA[哈希长度扩展攻击相信你一定能拿到想要的 Hint:你可能希望知道服务器端发生了什么。。 格式：CTF{} 链接 c语言中undefined reference to “”怎么解决 链接时缺失了相关目标文件（.o） 测试代码如下： 然后编译。 gcc -c test.c gcc –c main.c 得到两个 .o 文件，一个是 main.o，一个是 test.o ，然后我们链接 .o 得到可执行程序： gcc -o main main.o 这时，你会发现，报错了： main.o: In function main&#39;: main.c:(.text+0x7): undefined reference totest’ collect2: ld returned 1 exit status 这就是最典型的undefined reference错误，因为在链接时发现找不到某个函数的实现文件，本例中test.o文件中包含了test()函数的实现，所以如果按下面这种方式链接就没事了。 gcc -o main main.o test.o 【扩展】：其实上面为了让大家更加清楚底层原因，我把编译链接分开了，下面这样编译也会报undefined reference错，其实底层原因与上面是一样的。 gcc -o main main.c //缺少test()的实现文件 需要改成如下形式才能成功，将test()函数的实现文件一起编译。 gcc -o main main.c test.c //ok,没问题了 PHP中的序列化和反序列化此处的关键就是利用sha1算法的bug，sha1函数对参数为数组的情况会反回false 即可使第二个条件成立。php比较操作符的安全问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[冥想-从自己开始改变]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%86%A5%E6%83%B3-%E4%BB%8E%E8%87%AA%E5%B7%B1%E5%BC%80%E5%A7%8B%E6%94%B9%E5%8F%98%2F</url>
    <content type="text"><![CDATA[冥想的技巧&ensp;&ensp;&ensp;&ensp;将注意力专注于呼吸，什么也不要去想，每天二十分钟。&ensp;&ensp;&ensp;&ensp;当自己心情不好时，可以静下心来去冥想一些美好的经验。 两类痛苦&ensp;&ensp;&ensp;&ensp;一类是生理上的痛苦，比如别人打了你一巴掌。另一类是心理上的痛苦（贪、嗔、痴），比如别人打了打一巴掌，你很痛苦。&ensp;&ensp;&ensp;&ensp;往往第一类痛苦是无法避免的，但是我们可以控制住自己不去产生第二类痛苦，第二类痛苦往往是不会解决问题的，一是要意识到自己处于第二种痛苦，二是要知道这种痛苦是没有意义的，我们完全可以心平静气地去解决问题。 大脑偏爱痛苦的经验&ensp;&ensp;&ensp;&ensp;人类进化的主要目的就是生存，人类为了生存就要时刻提醒自己将来或者周边存在的危险，所以大脑倾向去产生不好的经验和推测，让自己产生不好的情绪，我们要意识到这一点。 改造自己痛苦的记忆&ensp;&ensp;&ensp;&ensp;研究发现，当两件事同时发生在自己的记忆里，大脑往往倾向于将两件事联系在一起，比如你绝望的时候，别人给予你了帮助，你内心的痛苦就稀释掉了，所以当你回忆痛苦的回忆时，将之与一段美好的回忆联系在一起，你就会发现就没有那么痛苦了。慢慢的你的记忆系统的结构就没你改变了，痛苦也不再是痛苦。 学会吸收美好&ensp;&ensp;&ensp;&ensp;记录每天让自己感到幸福和美好的事情，强化大脑对这种美好事情的感知能力，慢慢你会越来越觉得这个世界充满美好。 传播美好&ensp;&ensp;&ensp;&ensp;佛陀有一句话说：任何痛苦都来自于想让自己快乐，任何快来都来自于想让别人快乐。电影荒野求生中最后主人公濒死之际写下了一句话：幸福源于分享。 冥想让自己更加专注 （呼吸冥想、瑜伽）可以锻炼专注力。 一次只做一件事，不要分心，直到做完为止。 平静、清醒、安静，尽量少说话，多思考，生活尽量地简单一点。 辩证地看待问题&ensp;&ensp;&ensp;&ensp;看待一件事情尽量不要添加个人的主观情绪，这样的情绪会使自己盲目。要有效杜绝“恨”，就不要去为一个人或一件事提贴标签，一旦贴上了标签你就不能看到事情的真相了，要发现事情背后的规律或者原因，然后去解决问题。]]></content>
      <tags>
        <tag>reading note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[马克思主义哲学]]></title>
    <url>%2F2017%2F05%2F20%2F%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%93%B2%E5%AD%A6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[活法]]></title>
    <url>%2F2017%2F05%2F20%2F%E6%B4%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.人生的意义或价值何在？人为什么而活？目的是什么？总得为自己活着找个明确的理由，否则你的一生就是混乱的，动荡的。 2.提升心性，磨练灵魂（禅宗一直强调的就是磨练自己的心性，但是为何要磨练自己的心性，灵魂又为何物？），每个人肯定是为了追求幸福而活的，幸福是什么？简单的快乐吗？看似好像没那么简单。可以肯定的是，“提升心性，磨练灵魂”是禅宗获得幸福的途径，仔细想一想，能决定看你是否幸福快乐的，很大一部分是你自己心态，往往心态崩了，人生也就随之崩塌，也就是说所谓“提升心性，磨练灵魂”可能就是培养一颗强大的心，不以物喜，不以己悲，不会患得患失，时刻保持平和的心态，摆脱三毒（痴、嗔、贪）。所谓痴，就是嫉妒、憎恨、不满；所谓嗔，就是恼怒；所谓贪，便是欲望。人生不幸福，很大程度上是因为，这三毒充斥着自己的生活，所以说人生的意义就在于“提升心性，磨练灵魂”，似乎很有道理。（有人说，我就要出人头地，世人敬仰，这样我也会很快乐，很幸福，我不知道这样算不算执迷不悟，我觉得人生最重要的就是做事情，踏实做自己喜欢的事情，而不是拔城攻寨，整天想着去搞个大新闻，我觉得梦想和目标是要分开的，转念一想，万事讲究过犹不及，适度而为，三毒不能一棒子打死，适度的骄傲和不满为促进自己的进步，有梦想也要有目标，切不可做事情忘掉初衷，抛弃梦想，只谈目标，这样势必会走向歪门邪道）3.个人做事都应该有一个底线和原则，可以是道德，可以是法律，我决定应该比这连个更高，有可能你达不到社会主义核心价值观，但你应该努力。4.做事要精进，专注。5.]]></content>
      <tags>
        <tag>reading note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CryptoLock Stopping Ransomware Attacks on User Data]]></title>
    <url>%2F2017%2F05%2F15%2FCryptoLock-Stopping-Ransomware-Attacks-on-User-Data%2F</url>
    <content type="text"><![CDATA[目录 介绍和相关工作 标识 实现 实验评估 PS：平时多备份，灾时少流泪！ 一、介绍和相关工作1、现状 加密的数据是可恢复的（和破坏性的恶意软件不同） 通过比特币进行匿名支付 存在了将近十年 每年几百万美元的损失^[37] 法律机构收到侵害，损失重要文件（只能选择支付）^[4][18] 2、难点 这种恶意软件容易上手 通过行为难以区分是否为恶意软件 主要面向小白用户（从不会数据备份） 3、论文所做工作 Develp an early-warning system：第一个检测用户数据变化的检测系统，目的不是一个文件都不损失，而是损失一部分来发现恶意行为，终止行为。基于Windows平台。 Indentify three primary indicators：找到三个主要行为标识来标识这种恶意行为 Extensive analysis：正确率比较高（误判几乎为0，只有0.2%的文件损失）、健壮性好大大减少了文件损失和攻击者的利润。 4、相关工作（RELATE WORK）现存的技术区分程序是否为恶意软件，主要依靠两个特性：(异常检测的IDE系统使用的就是不同的机器学习和数据分析技术来甄别)&ensp; &ensp;1.什么是恶意软件 &ensp; &ensp; 2.恶意软件做什么 特征匹配（signature matching）没出现过的恶意软件就很难检测。逃避特征、自动打包技术 文件的完整性检测：（基于简单的hash值比较）文件出现变动就回提醒，无法区分合法or恶意，难用！ Andronio等人开发了一个Android平台上的检测工具（结合了动态和静态分析技术，如检测加密函数的调用和线程信息），桌面平台不好用。 本文的系统检测用户数据的变化，检测用户数据如何变化，注重于补救。 二、RANSOMWARE INDICATORS1、三类Ransomware A类：重写文件内容，打开文件、读内容、加密、替换信息、关闭文件。 B类：继承A，把文件移出，干完活再移进来 C类：打开文件，读文件，加密成一个新的文件，删除原来的文件。（独立的读写流） &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;忽略不直接修改文件的操作，如写随机数（防止数据恢复）等2、File Type Changes&ensp;&ensp;这些签名描述了文件类型唯一的特定字节值的顺序和位置，而不仅仅是文件头部信息。由于文件通常在其存在过程中保持其文件类型和格式，所以对这些数据进行批量修改的行为是值得怀疑的行为。 &ensp;&ensp;利用 The file utility 检测文件类型的改变，但是并不是所有的类型改变都是恶意的，有可能是程序更新。比如doc→docx 3、Similarity Measurement[27]][40] 强加密算法的输出文件不会提供有关明文的任何信息。所以说加密后的文件跟明文会完全不一样。 可以使用相似性保留Hash函数（similarity-preserving hash functions）来捕捉这种变化。使用sdhash来给相似性打分，0-100分，0表示一点都不一样，100表示完全一样。 给定最初版本的一个文件相似度散列，与该文件的加密版本应该不会匹配，因为密文不能与随机数据区分开来。因此，我们应该在比较时获得接近零的分数在比较的时候。 4、Shannon Entropy香农（熵）平均信息量，加密或压缩后的文件熵值很高，通过下面的公式计算熵值，e产生从0到8的值，其中8表示字节值的完美均匀分布阵列。加密文件将趋于接近8，以前也有人提出过，但不是专注于信息改变，而是为了区分勒索软件。公式：（见论文） 5、Secondary Indicators Union Indication Deletion：程序经常会删除创建文件，这并不是一个可疑操作，但是删除大量的文件可能就是恶意操作了，如C类勒索软件 File type funneling：用它读取多个文件类型，但只写一个类型在执行期间并不罕见， Ransomware利用这种情况的极端。当ransomware加密和写入数据时，我们会看到更少的输出文件类型，通过跟踪进程读取的文件类型的数量，设置阈值，超过阈值就是可疑的。(eg:Word) 6、Union IndicationWhile exploring the behavior of ransomware, we observed that none of the benign programs we tested triggered all three of our primary ransomware indicators, while the vast majority of ransomware samples did. We demonstrate in Section V that this union of primary indicators is crucial for early detection. Although each indicator provides value in isolation, we use union indication to take action faster.（总结：又好又快，联合指标检测打头阵） 7、Indicator EvasionHowever, evading the union of our three primary indicators will require significant effort on the part of an adversary. For instance, while padding a file with low entropy bits may cause our detector to miss it, such behavior will also concurrently skew similarity hashes. Attempts to make output files appear to maintain their original format may also be possible, but not without dramatically skewing the remaining two indicators.（绕过一个绕不过俩），总之就是很难绕过这些特征标识。 三、实现 CryptoDrop focuses on detecting ransomware through monitoring the real-time change of user data. The union of these individual indicators provides a strong measure of suspiciousness of a process. By tracking these indicators and monitoring for this condition in a single running process over time, we can develop a reputation score that indicates whether or not the program is likely behaving maliciously. Once a threshold score is reached, CryptoDrop alerts the user and suspends the suspicious process (or family of processes). In this way, we can prevent ransomware from completely encrypting a victim’s files, and contain the amount of damage in the event of infection. The primary challenge in constructing this system is detecting ransomware early while limiting false positives that could make the system impractical to use. A. Reputation Scoreboard顾名思义，需要维护一个进程的“信誉”分数板，当一个进程触发某个标识符的时候就给它加分，一旦达到某个可疑的阈值，挂起进程，请求用户的权限。 B. Union Indication Scoring 没有合法进程会触发三个指标，打分机制使我们能够保持我们的得分阈值低的情况下不会引起显着的误报，研究表明单一指标检测机制的情况下有很高的几率会产生误报，三个指标的情况下就低得多。 CryptoDrop的可靠性由ransomware的典型行为加强，这种行为经常触发所有三个主要指标 C. State Tracking and Score Assessment 我们利用了一个使用用允许我们介入进程和文件系统之间的调用的驱动程序的Windows内核。这样的方法使我们不仅可以检测何时文件被更改，也是为了防止我们的机制被恶意软件修改。 这种方法也防止了干扰磁盘加密系统（例如BitLocker），它们在文件系统和磁盘之间进行操作。 熵测量：Ransomware经常写付款指示。这些小的低熵写入过度影响熵的平均值。这个权重确保了低熵和小的读/写操作不会过度的影响平均值。 当受保护的文件被读取或写入时，我们计算出执行操作过程中该操作涉及的字节的熵更新读写操作的加权平均数。然后计算读写差值，差值超过0.1，说明行为可疑。 这种测量是无状态的，每次超过阈值的读写原子操作都会发生。尽管阈值相比熵值很小，但是它提供了一种检测小的熵值增加的压缩文件操作的解决方法。 四、实验评估A.实验准备 构造了5099个文件，放在了有511条目录的路径树当中 Windows7 SPI（64bit）2GB内存，关闭防火墙和反病毒软件等 以管理员身份运行 网络访问限制在主机的网络栈中 每次实验虚拟机都要回退到上个快照状态 安装CryptoDrop并且设置非联合检测的阈值为200 拿到了2663个恶意软件的样本，剔除了2171个（不能用的），剩下492（都修改用户数据）个，分属于14个家族。 B.恶意软件检测1.保护数据的能力-Data Loss 在检测到之前丢失数据的量是最有价值的度量，CryptoDrop检测越快，丢失的文件就越少，因此就能保护更多的文件。 有些软件会对不同类型文件有不同的优先级，但是这并不会影响CryptoDrop的检测能力，通过主要指标就可以很快发现恶意软件。 5099文件中大约10个文件会丢失（0.2%） B类恶意软件会有较高的丢失率（优先攻击小文件） 性能强于普通的 2.联合指标的有效性 试验中，三个主要指标是被证明在大部分样本中很有价值的。93%的样本都触发了联合指标检测，可以通过加快分数的增加和降低阈值来减少文件损失。 C类恶意软件可以逃脱联合指标检测，因为它将数据写入不同的文件。因为写操作熵值大，需要删除大量文件还是会被检测出来。 CryptoDrop的低非联合阈值机制允许检测到前丢失中位数为6个的文件数量。 关键的是加快了检测速度，把文件损失减少为一个。 C.以数据为中心的勒索软件行为 我们最初预计会发现大多数ransomware样品使用目录的有序列表执行深度优先搜索并在达到最深的文件后，依次加密它们。实验发现，并不是这样，如图4所示。 TeslaCrypt使用深度优先搜索，到达最深文件后开始访问文件，并不在第一个目录中加密文件，而是写解密指令或赎金要求，从第二个目录的PDF开始加密。 CTB-Locker只攻击特定的扩展名（.txt.md）,根据文件大小升序排列。按照顺序加密，无论是否在一个目录里, sdhash无法生成小文件的相似度分数，导致联合检测是不可能的。以后版本的CryptoDrop可以通过自动识别这种不利情况解决这个问题。一旦确定，CryptoDrop可以调整个别指标评估信誉分数。 GPcode从根部开始访问文件，不删除文件，删除文件内容，但是有些文件只读权限，所以可能什么都做不了。通过写的熵值还是可以检测到。 恶意软件攻击的文件的排序影响CryptoDrop检测和停止ransomware的速度。未来还需要做一些优化工作，动态评分工作，但是可能会对误报产生不利影响 D.文件格式攻击频率见图 E.Ransomware Script PoshCoder，不需要编译成二进制，容易变异，基于特征识别的反病毒软件检测率大大降低，CryptoDrop检测只有11个文件损失。 由于CryptoDrop专注于更改对用户数据而不是恶意软件的内容或其执行，我们的系统很好地停止了ransomware使用高级API操纵文件系统。 F.False Positive 对于CryptoDrop来说，误报分析很很困难的。 静态分析不行，因为CryptoDrop不分析软件的二进制特征 动态分析不行，因为CryptoDrop需要在每次更改之前和之后测量用户的文档 所以试验中论文加入良性软件来证明系统的健壮性 测试了30个Windows程序，只有一个误报（7.zip），而且没有英语触发三个指标。 分析五个重要的应用Adobe Lightroom (107)、ImageMagick (0)、iTunes (16)、Microsoft Word (0)、Microsoft Excel (150) 在我们的分析中，我们展示了我们的阈值选择可以最大限度地减少误报，同时保持快速检测勒索。 研究时间窗口参数化可能导致另一个主要指示器在未来版本的CryptoDrop。 G.限制CryptDrop无法知道文件发生改变的目的，无法区分是用户还是恶意软件（加密软件PGP、GPG、一些压缩软件，未来恶意软件也可能利用这些软件），但是CryptoDrop主要针对大宗的信息转换。不怕一万就怕万一！ H.性能最初设计没有考虑优化，有很延迟操作，如写和重命名，CryptoDrop不检查用户文档以外的文件目录，所以操作系统和程序访问其他文件（包括自己的）不受影响。写入和重命名的高延迟操作经常在测量过程中出现，所以一个主要的优化是执行这些测量的时候不需要额外的磁盘访问，这样会大大减少了这些延迟。CryptoDrop可以在具有较小开销的实时系统上运行 五、总结&ensp;&ensp;&ensp;&ensp;限制攻击者，减少对受害者损失，这是一种用于勒索软件攻击预警的系统。我们的解决方案是通过监控受害者的数据和ransomware必须的行为来实现的。首先确定这些所需的操作，进行分类ransomware分为三大类，并发现Ransomware的三个主要行为指标，找到一种低文件丢失率检测的快捷方式，针对ransomware规模最大的研究 参考文献 [1]OPF format corpus. http://openpreservation.org/technology/corpora/opf-format-corpus/. [2] N. Agrawal, W. J. Bolosky, J. R. Douceur, and J. R. Lorch. A five-year study offile-system metadata. ACM Transactions on Storage (TOS), 2007. [3] N. Andronio, S. Zanero, and F. Maggi. HelDroid: Dissecting and detecting mobile ransomware. In Proceedings of the International Symposium on Research inAttacks, Intrusion and Detection (RAID), 2015. [4] E. Arnold. Tennessee sheriff pays ransom to cybercriminals,in bitcoin. http://www.bizjournals.com/memphis/blog/2014/11/tennessee-sheriff-pays-ransom-to-cybercriminals-in.html, 2014. [5] S. Axelsson. The base-rate fallacy and its implications for the difficulty ofintrusion detection. In Proceedings of the ACM Conference on Computer andCommunications Security (CCS), 1999. [6] D. Carrigan. Police departments hit by ransomware virus. http://www.wcsh6.com/story/news/local/2015/04/10/police-departments-hit-by-ransomware-virus/25593777/, 2015. [7] S. Chakradeo, B. Reaves, P. Traynor, and W. Enck. MAST: Triage for marketscalemobile malware analysis. In Proceedings of ACM Conference on Securityand Privacy in Wireless and Mobile Networks (WiSec). ACM, 2013. [8] V. Chandola, A. Banerjee, and V. Kumar. Anomaly detection: A survey. ACMComput. Surv., 41(3), 2009. [9] X. Chen, J. Andersen, Z. M. Mao, M. Bailey, and J. Nazario. Towards an understandingof anti-virtualization and anti-debugging behavior in modern malware.In IEEE International Conference on Dependable Systems and Networks, 2008. [10] N. Coldwell. Comparison of audio compression. http://nigelcoldwell.co.uk/audio/. [11] D. Common. Ransomware victims pay cybercriminalsto save family photos. http://www.cbc.ca/news/technology/ransomware-victims-pay-cybercriminals-to-save-family-photos-1.2962106,2015. [12] Cuckoo Foundation. Automated malware analysis - cuckoo sandbox. http://www.cuckoosandbox.org/. [13] C. Cuevas and C. Shaffer. Raising the white flag. http://www.shmoocon.org/2012/videos/ShafferCuevas-RaisingTheWhiteFlag.m4v, 2012. Presented at ShmooCon. [14] T. Dewan. Teslacrypt joins ransomware field. https://blogs.mcafee.com/mcafee-labs/teslacrypt-joins-ransomware-field, 2015. [15] C. J. Dietrich, C. Rossow, and N. Pohlmann. Exploiting visual appearance tocluster and detect rogue software. In Proceedings of the ACM Symposium onApplied Computing. ACM, 2013. [16] J. R. Douceur and W. J. Bolosky. A large-scale study of file-system contents. InProceedings of the ACM SIGMETRICS International Conference on Measurementand Modeling of Computer Systems, 1999. [17] S. Forrest, S. A. Hofmeyr, A. Somayaji, and T. A. Longstaff. A sense of self forunix processes. In Proceedings of the IEEE Symposium on Security and Privacy(S&amp;P), 1996. [18] B. Fraga. Swansea police pay $750 “ransom” after computer virus strikes. TheHerald News, 2013. [19] S. Garfinkel, P. Farrell, V. Roussev, and G. Dinolt. Bringing science to digitalforensics with standardized forensic corpora. Digital Investigation, 6, Supplement(0), 2009. [20] G. Gu, P. Porras, V. Yegneswaran, M. Fong, and W. Lee. BotHunter: detectingmalware infection through IDS-driven dialog correlation. In Proceedings of theUSENIX Security Symposium, 2007. [21] D. Hadˇziosmanovi′c, L. Simionato, D. Bolzoni, E. Zambon, and S. Etalle. N-gramagainst the machine: On the feasibility of the N-gram network analysis for binaryprotocols. In Proceedings of the International Symposium on Research in Attacks,Intrusion and Detection (RAID), 2012. [22] B. J. Hicks, A. Dong, R. Palmer, and H. C. Mcalpine. Organizing and managingpersonal electronic files: A mechanical engineer’s perspective. ACM Transactionson Information Systems (TOIS), 26(4), 2008. [23] S. A. Hofmeyr, S. Forrest, and A. Somayaji. Intrusion detection using sequencesof system calls. International Journal of Information and Computer Security,6(3), 1998. [24] S. Jana and V. Shmatikov. Abusing file processing in malware detectors for funand profit. In IEEE Symposium on Security and Privacy (S&amp;P), 2012. [25] A. Kharraz, W. Robertson, D. Balzarotti, L. Bilge, and E. Kirda. Cutting thegordian knot: A look under the hood of ransomware attacks. DIMVA, 2015. [26] G. H. Kim and E. H. Spafford. The design and implementation of tripwire: A filesystem integrity checker. In Proceedings of the ACM Conference on Computerand Communications Security, 1994. [27] J. Kornblum. Identifying almost identical files using context triggered piecewisehashing. Digital Investigation, 3, Supplement(0), 2006. [28] S. Kumar and E. H. Spafford. A generic virus scanner for c++. In Proceedingsof the Computer Security Applications Conference, 1992. [29] A. Lanzi, D. Balzarotti, C. Kruegel, M. Christodorescu, and E. Kirda. Access-Miner: Using system-centric models for malware protection. In Proceedings ofthe ACM Conference on Computer and Communications Security (CCS), 2010. [30] C. Lever, M. Antonakakis, B. Reaves, P. Traynor, and W. Lee. The core of thematter: Analyzing malicious traffic in cellular carriers. In Proceedings of theNetwork and Distributed System Security Symposium (NDSS), 2013. [31] R. Lyda and J. Hamrock. Using entropy analysis to find encrypted and packedmalware. IEEE Security and Privacy, 5(2), 2007. [32] D. Maiorca, I. Corona, and G. Giacinto. Looking at the bag is not enoughto find the bomb: An evasion of structural methods for malicious PDF filesdetection. In Proceedings of the ACM Symposium on Information, Computerand Communications Security, 2013. [33] J. A. P. Marpaung, M. Sain, and H.-J. Lee. Survey on malware evasion techniques:State of the art and challenges. In International Conference on AdvancedCommunication Technology (ICACT), 2012. [34] Y. Nadji, J. Giffin, and P. Traynor. Automated remote repair for mobile malware.In Proceedings of the Annual Computer Security Applications Conference(ACSAC). ACM, 2011. [35] J. Oberheide, M. Bailey, and F. Jahanian. PolyPack: An automated online packingservice for optimal antivirus evasion. In Proceedings of the USENIX Conferenceon Offensive Technologies, 2009. [36] J. Oberheide, E. Cooke, and F. Jahanian. CloudAV: N-Version antivirus in thenetwork cloud. In USENIX Security Symposium, 2008. [37] G. O’Gorman and G. McDonald. Ransomware: A growing menace. Technicalreport, Symantec Corporation, 2012. [38] A. Patcha and J.-M. Park. An overview of anomaly detection techniques: Existingsolutions and latest technological trends. Computer Networks, 51(12), 2007. [39] R. Perdisci, A. Lanzi, and W. Lee. Classification of packed executables foraccurate computer virus detection. Pattern recognition letters, 29(14), 2008. [40] V. Roussev. Data fingerprinting with similarity digests. In Advances in DigitalForensics VI, IFIP Advances in Information and Communication Technology.Springer Berlin Heidelberg, 2010. [41] N. Scaife, H. Carter, and P. Traynor. OnionDNS: A seizure-resistant top-leveldomain. In In IEEE Conference on Communications and Network Security (CNS),2015. [42] I. Sorokin. Comparing files using structural entropy. Journal in ComputerVirology, 7(4), 2011. [43] A. Tang, S. Sethumadhavan, and S. Stolfo. Unsupervised Anomaly-basedMalware Detection using Hardware Features. In Proceedings of the InternationalSymposium on Research in Attacks, Intrusion and Detection (RAID), 2014. [44] D. J. Tian, A. Bates, and K. Butler. Defending against malicious USB firmwarewith GoodUSB. In Proceedings of the Annual Computer Security ApplicationsConference (ACSAC). ACM, 2015. [45] P. Traynor, M. Chien, S. Weaver, B. Hicks, and P. McDaniel. Noninvasive methodsfor host certification. ACM Transactions on Information and System Security,11(3), 2008. [46] X. Ugarte-Pedrero, D. Balzarotti, I. Santos, P. G. Bringas, and S. Antipolis. SoK: Deep Packer Inspection : A Longitudinal Study of the Complexity of Run-TimePackers. In IEEE Symposium on Security and Privacy (S&amp;P), 2015. [47] A. Viswanathan, K. Tan, and C. Neuman. Deconstructing the assessment ofanomaly-based intrusion detectors. In Proceedings of the International Symposiumon Research in Attacks, Intrusion and Detection (RAID), 2013. [48] J. Walter. Meet tox: Ransomware for the rest of us. https://blogs.mcafee.com/mcafee-labs/meet-tox-ransomware-for-the-rest-of-us/, 2015. [49] C. Warrender, S. Forrest, and B. Pearlmutter. Detecting intrusions using systemcalls: alternative data models. In Proceedings of the IEEE Symposium on Securityand Privacy (S&amp;P), 1999. [50] H. Weisbaum. CryptoLocker crooks launch ‘customer service’ site. http://www.cnbc.com/id/101195861, 2013.]]></content>
  </entry>
  <entry>
    <title><![CDATA[SMS-短信加密程序]]></title>
    <url>%2F2017%2F05%2F14%2FSMS-%E7%9F%AD%E4%BF%A1%E5%8A%A0%E5%AF%86%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[目录 程序设计及编写 遇见的问题 一些加密算法的原理 收获（数据库的使用以及二维码） 参考 _github_ 短信加密分四步走（目标：实现前三步） 编写短信收发程序 实现AES加密 实现RSA/Diffi-Hellman的非对称加密的密钥交换 实现RSA签名（MAC技术） 一、程序设计1.发送过程设计：1.1 发送界面： 1.2 发送过程设计1.2.1使用过程设计 1234567891011121314151617如果不需要加密发送 直接输入电话号码和信息 点击发送否则 如果是第一次使用软件 生成自己的非对称密钥保存到自己数据库里面（后边的签名和对称密钥交换需要） 如果不是第一次使用该软件 如果需要和新人（不知道对方公钥的人）发送信息 输入“0”，查询自己的公钥 和对方交换公钥 输入对方的电话号码和公钥，保存对方的公钥 如果和已知对方公钥的好友发送信息 如果想要变换回话密钥或者第一次与对方通话 需要发送回话密钥给对方 否则 直接输入对方电话号码和信息 点击加密发送信息 1.2.2 使用细节设计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950发送：（MessageManager）创建PendingIntent对象获取电话号码和消息判断号码是否为空不为空则 由于短信的字符数限制，需要分割消息（&gt;70），使用divideMessage方法 分条发送加密发送：获取电话号码和消息从数据库中取出AES密钥字符串（Base64编码）将AES密钥字符串转化成（SecretKeySpec）密钥对象创建并初始化加密算法对象（Ciper）加密（doFinal函数）消息将加密的消息进行Base64编码消息头部加入密文标志字符串发送发送密钥：获取电话号码和消息从数据库中取出对应的公钥如果取出的公钥不为空 生成AES密钥 Base64编码AES密钥 判断数据库中AES回话密钥是否已经存在 如果存在 修改AES密钥（updateKey） 如果不存在 插入AES密钥（insertKey） 将取出的公钥转化成公钥对象 加密编码后的密钥 头部加入密钥标志字符串 发送生成非对称密钥：利用RSA—API生成公钥和私钥将公钥和私钥对象进行Base64编码成字符串判断是该用户否已经存在公钥和私钥存在 更新密钥不存在 存入数据库保存公钥：扫码得到公钥将对方公钥存入数据库查询公钥：将公钥取出数据库生成二维码 1.3数据库设计数据库一个表三个字段 电话号码、密钥、公钥or对称密钥特殊字段 电话号码为0 密钥为自己的公钥 1 密钥为自己的私钥1CREATE TABLE Key (phoneNum char(11), key varchar(64),bool char(1)) 2.接受过程设计2.1 接受界面 2.2 接受过程原理当手机收到短信的时候，会向系统广播这条消息，我们需要创建一个继承自BroadcastRecciver的类，并重写其OnReceive方法来接受并处理这条广播消息。 2.3 接受过程设计1234567891011121314151617181920接收到短信提取短信的信息和电话号码（Bundle对象）合并消息内容判断是明文、密文or密钥是明文，不做处理，显示到接受界面中是密文 将消息Base64解码成byte对象 根据电话号码找到对应的密钥 把密钥转字符串化成密钥对象 对消息执行解密 将机密后的消息转换成字符串对象，直接new String（） 显示到接受界面中是密钥 根据电话号码找到相应的公钥 将公钥字符串转化为公钥对象 对消息执行解密 将解密后的回话密钥和电话号码存入数据库 判断是否已经存在回话密钥 存在，则替换（updateKey） 不存在，直接出入（insertKey） 二、程序具体实现1、编写短信收发程序【1】【2】1.1 发送短信12345678910111213//创建一个PendingIntent对象 PendingIntent pi = PendingIntent.getActivity(MainActivity.this, 0, new Intent(), 0); //发送短信 //短信具有字数限制，分条发送 ArrayList&lt;String&gt; list = sManager.divideMessage(content.getText().toString()); //因为一条短信有字数限制，因此要将长短信拆分 for(String text:list) &#123; sManager.sendTextMessage(number.getText().toString(), null, text, pi, null); &#125; // sManager.sendTextMessage(number.getText().toString(), null, content.getText().toString(), pi, null); //提示短信发送成功 Toast.makeText(MainActivity.this, &quot;短信发送成功&quot;, Toast.LENGTH_LONG).show(); 1.2接受短息系统受到短信之后欧会进行广播。Broadcast Reciver的使用AndroidManifest.xml文件需要注册Receiver 123456789 &lt;receiver android:name=&quot;.MessageReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; &gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; /&gt;//只接受短信消息，优先级为1000，高于系统短信软件的。 &lt;/intent-filter&gt; &lt;/receiver&gt; 添加权限 123&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt; 接收短信代码(Onreceive) 123456789101112131415161718Bundle bundle = intent.getExtras();// 提取短信消息 Object[] pdus = (Object[]) bundle.get(&quot;pdus&quot;);SmsMessage[] messages = new SmsMessage[pdus.length];for (int i = 0; i &lt; messages.length; i++)&#123; messages[i] = SmsMessage.createFromPdu((byte[]) pdus[i]);&#125;String address = messages[0].getOriginatingAddress(); // 获取发送方号码 String fullMessage = &quot;&quot;;//合并短信for (SmsMessage message : messages) &#123; fullMessage += message.getMessageBody(); // 获取短信内容&#125; AES加解密参考 1234567891011121314//生成key KeyGenerator kg = KeyGenerator.getInstance(&quot;AES&quot;); kg.init(128, new SecureRandom(passwd.getBytes())); Key k = kg.generateKey(); //初始化 Cipher cf = Cipher.getInstance(&quot;AES&quot;); cf.init(Cipher.ENCRYPT_MODE, k);//加密 byte[] bs1 = cf.doFinal(msg1.getBytes());//初始化 cf.init(Cipher.DECRYPT_MODE, k);//解密 byte[] msg2 = cf.doFinal(bs1); System.out.println(&quot;plain text: &quot; + &quot;\&quot;&quot; + new String(msg2) + &quot;\&quot;&quot;); RSA加解密参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224package com.example.xx.sms_en;import java.math.BigInteger;import java.security.*;import java.security.interfaces.*;import java.security.spec.RSAPrivateKeySpec;import java.security.spec.RSAPublicKeySpec;import java.util.*;import javax.crypto.Cipher;/** * Created by Mr.Chen on 2017/5/15. */public class RSA&#123; /** * 生成公钥和私钥 * @throws NoSuchAlgorithmException * */ public static HashMap&lt;String, Object&gt; getKeys() throws NoSuchAlgorithmException &#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(&quot;RSA&quot;); keyPairGen.initialize(1024); KeyPair keyPair = keyPairGen.generateKeyPair(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); map.put(&quot;public&quot;, publicKey); map.put(&quot;private&quot;, privateKey); return map; &#125; /** * 使用模和指数生成RSA公钥 * 注意：【此代码用了默认补位方式，为RSA/None/PKCS1Padding，不同JDK默认的补位方式可能不同，如Android默认是RSA * /None/NoPadding】 * * @param modulus * 模 * @param exponent * 指数 * @return */ public static RSAPublicKey getPublicKey(String modulus, String exponent) &#123; try &#123; BigInteger b1 = new BigInteger(modulus); BigInteger b2 = new BigInteger(exponent); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); RSAPublicKeySpec keySpec = new RSAPublicKeySpec(b1, b2); return (RSAPublicKey) keyFactory.generatePublic(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 使用模和指数生成RSA私钥 * 注意：【此代码用了默认补位方式，为RSA/None/PKCS1Padding，不同JDK默认的补位方式可能不同，如Android默认是RSA * /None/NoPadding】 * * @param modulus * 模 * @param exponent * 指数 * @return */ public static RSAPrivateKey getPrivateKey(String modulus, String exponent) &#123; try &#123; BigInteger b1 = new BigInteger(modulus); BigInteger b2 = new BigInteger(exponent); KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(b1, b2); return (RSAPrivateKey) keyFactory.generatePrivate(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 得到密钥字符串（经过base64编码） * @return */// public static String getKeyString(Key key) throws Exception &#123;// byte[] keyBytes = key.getEncoded();// String s = (new BASE64Encoder()).encode(keyBytes);// return s;// &#125; /** * 公钥加密 * * @param data * @param publicKey * @return * @throws Exception */ public static String encryptByPublicKey(String data, RSAPublicKey publicKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.ENCRYPT_MODE, publicKey); // 模长 int key_len = publicKey.getModulus().bitLength() / 8; // 加密数据长度 &lt;= 模长-11 String[] datas = splitString(data, key_len - 11); String mi = &quot;&quot;; //如果明文长度大于模长-11则要分组加密 for (String s : datas) &#123; mi += bcd2Str(cipher.doFinal(s.getBytes())); &#125; return mi; &#125; /** * 私钥解密 * * @param data * @param privateKey * @return * @throws Exception */ public static String decryptByPrivateKey(String data, RSAPrivateKey privateKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.DECRYPT_MODE, privateKey); //模长 int key_len = privateKey.getModulus().bitLength() / 8; byte[] bytes = data.getBytes(); byte[] bcd = ASCII_To_BCD(bytes, bytes.length); System.err.println(bcd.length); //如果密文长度大于模长则要分组解密 String ming = &quot;&quot;; byte[][] arrays = splitArray(bcd, key_len); for(byte[] arr : arrays)&#123; ming += new String(cipher.doFinal(arr)); &#125; return ming; &#125; /** * ASCII码转BCD码 * */ public static byte[] ASCII_To_BCD(byte[] ascii, int asc_len) &#123; byte[] bcd = new byte[asc_len / 2]; int j = 0; for (int i = 0; i &lt; (asc_len + 1) / 2; i++) &#123; bcd[i] = asc_to_bcd(ascii[j++]); bcd[i] = (byte) (((j &gt;= asc_len) ? 0x00 : asc_to_bcd(ascii[j++])) + (bcd[i] &lt;&lt; 4)); &#125; return bcd; &#125; public static byte asc_to_bcd(byte asc) &#123; byte bcd; if ((asc &gt;= &apos;0&apos;) &amp;&amp; (asc &lt;= &apos;9&apos;)) bcd = (byte) (asc - &apos;0&apos;); else if ((asc &gt;= &apos;A&apos;) &amp;&amp; (asc &lt;= &apos;F&apos;)) bcd = (byte) (asc - &apos;A&apos; + 10); else if ((asc &gt;= &apos;a&apos;) &amp;&amp; (asc &lt;= &apos;f&apos;)) bcd = (byte) (asc - &apos;a&apos; + 10); else bcd = (byte) (asc - 48); return bcd; &#125; /** * BCD转字符串 */ public static String bcd2Str(byte[] bytes) &#123; char temp[] = new char[bytes.length * 2], val; for (int i = 0; i &lt; bytes.length; i++) &#123; val = (char) (((bytes[i] &amp; 0xf0) &gt;&gt; 4) &amp; 0x0f); temp[i * 2] = (char) (val &gt; 9 ? val + &apos;A&apos; - 10 : val + &apos;0&apos;); val = (char) (bytes[i] &amp; 0x0f); temp[i * 2 + 1] = (char) (val &gt; 9 ? val + &apos;A&apos; - 10 : val + &apos;0&apos;); &#125; return new String(temp); &#125; /** * 拆分字符串 */ public static String[] splitString(String string, int len) &#123; int x = string.length() / len; int y = string.length() % len; int z = 0; if (y != 0) &#123; z = 1; &#125; String[] strings = new String[x + z]; String str = &quot;&quot;; for (int i=0; i&lt;x+z; i++) &#123; if (i==x+z-1 &amp;&amp; y!=0) &#123; str = string.substring(i*len, i*len+y); &#125;else&#123; str = string.substring(i*len, i*len+len); &#125; strings[i] = str; &#125; return strings; &#125; /** *拆分数组 */ public static byte[][] splitArray(byte[] data,int len)&#123; int x = data.length / len; int y = data.length % len; int z = 0; if(y!=0)&#123; z = 1; &#125; byte[][] arrays = new byte[x+z][]; byte[] arr; for(int i=0; i&lt;x+z; i++)&#123; arr = new byte[len]; if(i==x+z-1 &amp;&amp; y!=0)&#123; System.arraycopy(data, i*len, arr, 0, y); &#125;else&#123; System.arraycopy(data, i*len, arr, 0, len); &#125; arrays[i] = arr; &#125; return arrays; &#125;&#125; 密钥编码格式转化代码(由字符串转化为对象) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.example.xx.sms_en;import android.util.Base64;import android.widget.Toast;import java.security.*;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.InvalidKeySpecException;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.SecretKeySpec;/** * Created by xx on 2017/5/19. */public class Coder&#123; public static RSAPublicKey getRSAPublidKeyBybase64(String base64s) &#123; X509EncodedKeySpec keySpec = new X509EncodedKeySpec(Base64.decode(base64s,Base64.DEFAULT)); RSAPublicKey publicKey = null; try &#123; KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); publicKey = (RSAPublicKey)keyFactory.generatePublic(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return publicKey; &#125; public static RSAPrivateKey getRSAPrivateKeyBybase64(String base64s) &#123; PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(Base64.decode(base64s, Base64.DEFAULT)); RSAPrivateKey privateKey = null; try &#123; KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); privateKey = (RSAPrivateKey)keyFactory.generatePrivate(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return privateKey; &#125; public static Key getKeyBybase64(String base64s) &#123; SecretKeySpec keySpec = new SecretKeySpec(Base64.decode(base64s, Base64.DEFAULT),&quot;AES&quot;); SecretKey k = null; try &#123; SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;AES&quot;); k = keyFactory.generateSecret(keySpec); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return k; &#125;&#125; 三、遇见的问题及解决方法1.权限不足 1.1在AndroidMainfest文件中添加相应的权限 1&lt;uses-permission android:name=&quot;android.permission.xxx&quot;/&gt; 1.2 在手机中给相应的权限（华为手机需要自己到设置中给权限，vivo会提示） 2.无法屏蔽系统短息 真机系统的系统短息经过特殊设置，是无法通过设置优先级别来屏蔽掉的，所以会收到两条信息，很烦。 3.无法找到该加密算法（AES）IllegalBlockSizeException:last block incomplete in decryption异常 keyFactory对象中没有实现AES加密，所以不能用【3】 12SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;AES&quot;); k = keyFactory.generateSecret(keySpec); 改用 123SecretKeySpec keySpec = new SecretKeySpec(Base64.decode(key, Base64.DEFAULT), &quot;AES&quot;); Cipher cf = Cipher.getInstance(&quot;AES&quot;); cf.init(Cipher.ENCRYPT_MODE, keySpec); 4.调用另一个APP的时候闪退Mainfest文件中有几个activity就要加几个activity节点 5.logcat没有报错信息好像只有我的华为手机没有，用别的手机还是可以的。看了一些方法：如设置信息级别最低verbose，没有过滤字等，巴拉巴拉很多，自行百度吧，弄了很长时间发现是手机的问题。 四、收获1.加密算法的原理和过程简单的加密过程 1、甲方构建密钥对（公钥和私钥，公钥给对方，私钥留给自己） 2、甲方使用私钥加密数据，然后用私钥对加密后的数据签名，并把这些发送给乙方；乙方使用公钥、签名来验证待解密数据是否有效，如果有效使用公钥对数据解密。 3、乙方使用公钥加密数据，向甲方发送经过加密后的数据；甲方获得加密数据，通过私钥解密。 2.RSA的原理1234567891011 随意选择两个大的质数p和q，p不等于q，计算N=pq。 根据欧拉函数，求得r = (p-1)(q-1) 选择一个小于 r 的整数 e，求得 e 关于模 r 的模反元素，命名为d。（模反元素存在，当且仅当e与r互质） 将 p 和 q 的记录销毁。(N,e)是公钥，(N,d)是私钥。Alice将她的公钥(N,e)传给Bob，而将她的私钥(N,d)藏起来。c^d ≡ n (mod N) 得到n后，她可以将原来的信息m重新复原。解码的原理是： c^d ≡ n e·d(mod N)以及ed ≡ 1 (mod p-1)和ed ≡ 1 (mod q-1)。由费马小定理可证明（因为p和q是质数） n^e·d ≡ n (mod p)和n^e·d ≡ n (mod q)这说明（因为p和q是不同的质数，所以p和q互质） n^e·d ≡ n (mod pq) 3.Diffie–Hellman key exchange原理：1234567A、B各自选择随机数Xa、Xb A、B各自计算Ya、Yb Y=p^Xmod q交换Ya，YbA计算K＝Yb^Xa mod q B计算K&apos;＝Ya^Xb mod q 事实上，K＝K&apos; JDK支持DH密钥协商,由于JDK兼顾和统一了各种不同的密钥协商和管理机制，因此用法复杂。 2.数据库SQLite的使用SQLiteOpenHelper是Android提供的一个管理数据库的工具类，可用于管理数据库的创建和版木更新。一般的用法是创建SQLiteOpenHelper的子类，并扩展它的onCreate (SQLiteDatabasedb)和 onUpgrade 方法。 SQLiteOpenHelper提供了getReadableDatabase()、 getWritableDatabase()两个方法用于打开数据库连接，并提供了close方法来关闭数据库连接。如：1SQLiteDatabase db =helper.getWritableDatabase(); Android的SQLiteDatabase 提供了 insert、upate、delete或 query 语句来操作数据库。具体使用参考【4】。 3.二维码生成和扫描【5】【6】 [googleZxing开源地址] (https://github.com/zxing/zxing) 具体使用参考【5】、【6】 五、参考【1】http://www.jb51.net/article/91027.htm【2】http://www.cnblogs.com/zgqys1980/p/5342020.html【3】http://www.cnblogs.com/zgqys1980/p/5342020.html【4】https://wenku.baidu.com/view/02cc1268cbaedd3383c4bb4cf7ec4afe04a1b104.html【5】http://www.jianshu.com/p/e80a85b17920【6】http://blog.csdn.net/books1958/article/details/46346531]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Windows Server搭建AD域控制服务器]]></title>
    <url>%2F2017%2F05%2F12%2F%E7%94%A8Windows-Server%E6%90%AD%E5%BB%BAAD%E5%9F%9F%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hexo搭站笔记]]></title>
    <url>%2F2017%2F05%2F12%2Fhexo%E6%90%AD%E7%AB%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[利用GitHub+Hexo搭建个人博客&ensp;&ensp;想想作为一名合格的程序员还是应该有自己的Blog的，虽然技术比较渣，但有些东西应该记录下来，方便自己以后用，说不定还是难忘的回忆，主要是可以装逼。参考教程（所有教程过程都是相似的） 如何搭建一个独立博客——简明Github Pages与Hexo教程 使用hexo+github搭建免费个人博客详细教程 一步步在GitHub上创建博客主页 目录 (分三步) 拥有一个GitHub账号（可以注册域名，然后绑定） 安装hexo（包括一系列配置） 布置属于自己的网站 1、拥有一个GitHub账号&ensp;&ensp;这个就不多说了去GitHub注册一个就好了。如果注册都不会还是放弃治疗吧。2、创建一个仓库&ensp;&ensp;(好懒啊不想贴图)但是不贴图怎么说得清楚字符效果和横线等 删除线 删除线（开启识别HTML标签时）斜体字 斜体字粗体 粗体粗斜体 粗斜体 上标：X2，下标：O2 缩写(同HTML的abbr标签) 即更长的单词或短语的缩写形式，前提是开启识别HTML标签时，已默认开启 The HTML specification is maintained by the W3C. 引用 Blockquotes 引用文本 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 多语言代码高亮 Codes行内代码 Inline code执行命令：npm install marked 缩进风格即缩进四个空格，也做为实现类似&lt;pre&gt;预格式化文本(Preformatted Text)的功能。 &lt;?php echo &quot;Hello world!&quot;; ?&gt; 预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | JS代码 123456789101112131415161718192021222324252627282930313233343536function test()&#123; console.log("Hello world!");&#125; (function()&#123; var box = function()&#123; return box.fn.init(); &#125;; box.prototype = box.fn = &#123; init : function()&#123; console.log('box.init()'); return this; &#125;, add : function(str)&#123; alert("add", str); return this; &#125;, remove : function(str)&#123; alert("remove", str); return this; &#125; &#125;; box.fn.init.prototype = box.fn; window.box =box;&#125;)();var testBox = box();testBox.add("jQuery").remove("jQuery"); HTML代码 HTML codes12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest="utf-8" /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello world!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; GFM task list [x] GFM task list 1 [x] GFM task list 2 [ ] GFM task list 3 [ ] GFM task list 3-1 [ ] GFM task list 3-2 [ ] GFM task list 3-3 [ ] GFM task list 4 [ ] GFM task list 4-1 [ ] GFM task list 4-2 绘制表格 Tables 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 First Header Second Header Content Cell Content Cell Content Cell Content Cell First Header Second Header Content Cell Content Cell Content Cell Content Cell Function name Description help() Display the help window. destroy() Destroy your computer! Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes&copy; &amp; &uml; &trade; &iexcl; &pound;&amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo; 18&ordm;C &quot; &apos; 反斜杠 Escape*literal asterisks* 科学公式 TeX(KaTeX)$$E=mc^2$$ 行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。 $$(\sqrt{3x-1}+(1+x)^2)$$ $$\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))$$ 多行公式： 12345\displaystyle\left( \sum\_&#123;k=1&#125;^n a\_k b\_k \right)^2\leq\left( \sum\_&#123;k=1&#125;^n a\_k^2 \right)\left( \sum\_&#123;k=1&#125;^n b\_k^2 \right) 123456789\displaystyle \frac&#123;1&#125;&#123; \Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123; \frac25 \pi&#125;&#125; = 1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123; 1+\frac&#123;e^&#123;-6\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\cdots&#125; &#125; &#125; &#125; 123f(x) = \int_&#123;-\infty&#125;^\infty \hat f(\xi)\,e^&#123;2 \pi i \xi x&#125; \,d\xi]]></content>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我们应该泛滥]]></title>
    <url>%2F2017%2F05%2F11%2F%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E6%B3%9B%E6%BB%A5%2F</url>
    <content type="text"><![CDATA[生活像河流从西到东初中、高中、大学，我们迈着既定的步伐前进没有一点尝试没有一点泛滥风险最小就是最好适者生存是我们的法则我们遵循同样的法则总有一些离经叛道的人他们打破常规也许他们创造了世界也许他们即将被社会淘汰在我看来他们拯救了自己而我却没有勇气因为风险最小就是最好因为适者生存是我的法则生活就是温水但我还是害怕冷]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Poem</tag>
      </tags>
  </entry>
</search>